command: docker container run
aliases: docker container run, docker run
short: 基于镜像创建并运行新容器
long: |-
    `docker run` 会在一个全新的容器中运行指定命令；如有需要会自动拉取镜像，并启动该容器。

    你可以使用 `docker start` 重新启动已停止的容器，容器之前的更改都会被保留。
    使用 `docker ps -a` 可查看所有容器的列表（包含已停止的容器）。
usage: docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
pname: docker container
plink: docker_container.yaml
options:
    - option: add-host
      value_type: list
      description: Add a custom host-to-IP mapping (host:ip)
      details_url: '#add-host'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: annotation
      value_type: map
      default_value: map[]
      description: |
        Add an annotation to the container (passed through to the OCI runtime)
      deprecated: false
      hidden: false
      min_api_version: "1.43"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: attach
      shorthand: a
      value_type: list
      description: Attach to STDIN, STDOUT or STDERR
      details_url: '#attach'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: blkio-weight
      value_type: uint16
      default_value: "0"
      description: |
        Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: blkio-weight-device
      value_type: list
      default_value: '[]'
      description: Block IO weight (relative device weight)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cap-add
      value_type: list
      description: Add Linux capabilities
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cap-drop
      value_type: list
      description: Drop Linux capabilities
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cgroup-parent
      value_type: string
      description: Optional parent cgroup for the container
      details_url: '#cgroup-parent'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cgroupns
      value_type: string
      description: |-
        Cgroup namespace to use (host|private)
        'host':    Run the container in the Docker host's cgroup namespace
        'private': Run the container in its own private cgroup namespace
        '':        Use the cgroup namespace as configured by the
                   default-cgroupns-mode option on the daemon (default)
      deprecated: false
      hidden: false
      min_api_version: "1.41"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cidfile
      value_type: string
      description: Write the container ID to the file
      details_url: '#cidfile'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpu-count
      value_type: int64
      default_value: "0"
      description: CPU count (Windows only)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
      os_type: windows
    - option: cpu-percent
      value_type: int64
      default_value: "0"
      description: CPU percent (Windows only)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
      os_type: windows
    - option: cpu-period
      value_type: int64
      default_value: "0"
      description: Limit CPU CFS (Completely Fair Scheduler) period
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpu-quota
      value_type: int64
      default_value: "0"
      description: Limit CPU CFS (Completely Fair Scheduler) quota
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpu-rt-period
      value_type: int64
      default_value: "0"
      description: Limit CPU real-time period in microseconds
      deprecated: false
      hidden: false
      min_api_version: "1.25"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpu-rt-runtime
      value_type: int64
      default_value: "0"
      description: Limit CPU real-time runtime in microseconds
      deprecated: false
      hidden: false
      min_api_version: "1.25"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpu-shares
      shorthand: c
      value_type: int64
      default_value: "0"
      description: CPU shares (relative weight)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpus
      value_type: decimal
      description: Number of CPUs
      deprecated: false
      hidden: false
      min_api_version: "1.25"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpuset-cpus
      value_type: string
      description: CPUs in which to allow execution (0-3, 0,1)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: cpuset-mems
      value_type: string
      description: MEMs in which to allow execution (0-3, 0,1)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: detach
      shorthand: d
      value_type: bool
      default_value: "false"
      description: Run container in background and print container ID
      details_url: '#detach'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: detach-keys
      value_type: string
      description: Override the key sequence for detaching a container
      details_url: '#detach-keys'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device
      value_type: list
      description: Add a host device to the container
      details_url: '#device'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device-cgroup-rule
      value_type: list
      description: Add a rule to the cgroup allowed devices list
      details_url: '#device-cgroup-rule'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device-read-bps
      value_type: list
      default_value: '[]'
      description: Limit read rate (bytes per second) from a device
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device-read-iops
      value_type: list
      default_value: '[]'
      description: Limit read rate (IO per second) from a device
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device-write-bps
      value_type: list
      default_value: '[]'
      description: Limit write rate (bytes per second) to a device
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: device-write-iops
      value_type: list
      default_value: '[]'
      description: Limit write rate (IO per second) to a device
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: disable-content-trust
      value_type: bool
      default_value: "true"
      description: Skip image verification
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: dns
      value_type: list
      description: Set custom DNS servers
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: dns-opt
      value_type: list
      description: Set DNS options
      deprecated: false
      hidden: true
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: dns-option
      value_type: list
      description: Set DNS options
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: dns-search
      value_type: list
      description: Set custom DNS search domains
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: domainname
      value_type: string
      description: Container NIS domain name
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: entrypoint
      value_type: string
      description: Overwrite the default ENTRYPOINT of the image
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: env
      shorthand: e
      value_type: list
      description: Set environment variables
      details_url: '#env'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: env-file
      value_type: list
      description: Read in a file of environment variables
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: expose
      value_type: list
      description: Expose a port or a range of ports
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: gpus
      value_type: gpu-request
      description: GPU devices to add to the container ('all' to pass all GPUs)
      details_url: '#gpus'
      deprecated: false
      hidden: false
      min_api_version: "1.40"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: group-add
      value_type: list
      description: Add additional groups to join
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-cmd
      value_type: string
      description: Command to run to check health
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-interval
      value_type: duration
      default_value: 0s
      description: Time between running the check (ms|s|m|h) (default 0s)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-retries
      value_type: int
      default_value: "0"
      description: Consecutive failures needed to report unhealthy
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-start-interval
      value_type: duration
      default_value: 0s
      description: |
        Time between running the check during the start period (ms|s|m|h) (default 0s)
      deprecated: false
      hidden: false
      min_api_version: "1.44"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-start-period
      value_type: duration
      default_value: 0s
      description: |
        Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)
      deprecated: false
      hidden: false
      min_api_version: "1.29"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: health-timeout
      value_type: duration
      default_value: 0s
      description: Maximum time to allow one check to run (ms|s|m|h) (default 0s)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: help
      value_type: bool
      default_value: "false"
      description: Print usage
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: hostname
      shorthand: h
      value_type: string
      description: Container host name
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: init
      value_type: bool
      default_value: "false"
      description: |
        Run an init inside the container that forwards signals and reaps processes
      details_url: '#init'
      deprecated: false
      hidden: false
      min_api_version: "1.25"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: interactive
      shorthand: i
      value_type: bool
      default_value: "false"
      description: Keep STDIN open even if not attached
      details_url: '#interactive'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: io-maxbandwidth
      value_type: bytes
      default_value: "0"
      description: Maximum IO bandwidth limit for the system drive (Windows only)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
      os_type: windows
    - option: io-maxiops
      value_type: uint64
      default_value: "0"
      description: Maximum IOps limit for the system drive (Windows only)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
      os_type: windows
    - option: ip
      value_type: string
      description: IPv4 address (e.g., 172.30.100.104)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: ip6
      value_type: string
      description: IPv6 address (e.g., 2001:db8::33)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: ipc
      value_type: string
      description: IPC mode to use
      details_url: '#ipc'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: isolation
      value_type: string
      description: Container isolation technology
      details_url: '#isolation'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: kernel-memory
      value_type: bytes
      default_value: "0"
      description: Kernel memory limit
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: label
      shorthand: l
      value_type: list
      description: Set meta data on a container
      details_url: '#label'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: label-file
      value_type: list
      description: Read in a line delimited file of labels
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: link
      value_type: list
      description: Add link to another container
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: link-local-ip
      value_type: list
      description: Container IPv4/IPv6 link-local addresses
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: log-driver
      value_type: string
      description: Logging driver for the container
      details_url: '#log-driver'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: log-opt
      value_type: list
      description: Log driver options
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: mac-address
      value_type: string
      description: Container MAC address (e.g., 92:d0:c6:0a:29:33)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: memory
      shorthand: m
      value_type: bytes
      default_value: "0"
      description: Memory limit
      details_url: '#memory'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: memory-reservation
      value_type: bytes
      default_value: "0"
      description: Memory soft limit
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: memory-swap
      value_type: bytes
      default_value: "0"
      description: |
        Swap limit equal to memory plus swap: '-1' to enable unlimited swap
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: memory-swappiness
      value_type: int64
      default_value: "-1"
      description: Tune container memory swappiness (0 to 100)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: mount
      value_type: mount
      description: Attach a filesystem mount to the container
      details_url: '#mount'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: name
      value_type: string
      description: Assign a name to the container
      details_url: '#name'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: net
      value_type: network
      description: Connect a container to a network
      deprecated: false
      hidden: true
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: net-alias
      value_type: list
      description: Add network-scoped alias for the container
      deprecated: false
      hidden: true
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: network
      value_type: network
      description: Connect a container to a network
      details_url: '#network'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: network-alias
      value_type: list
      description: Add network-scoped alias for the container
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: no-healthcheck
      value_type: bool
      default_value: "false"
      description: Disable any container-specified HEALTHCHECK
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: oom-kill-disable
      value_type: bool
      default_value: "false"
      description: Disable OOM Killer
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: oom-score-adj
      value_type: int
      default_value: "0"
      description: Tune host's OOM preferences (-1000 to 1000)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: pid
      value_type: string
      description: PID namespace to use
      details_url: '#pid'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: pids-limit
      value_type: int64
      default_value: "0"
      description: Tune container pids limit (set -1 for unlimited)
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: platform
      value_type: string
      description: Set platform if server is multi-platform capable
      deprecated: false
      hidden: false
      min_api_version: "1.32"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: privileged
      value_type: bool
      default_value: "false"
      description: Give extended privileges to this container
      details_url: '#privileged'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: publish
      shorthand: p
      value_type: list
      description: Publish a container's port(s) to the host
      details_url: '#publish'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: publish-all
      shorthand: P
      value_type: bool
      default_value: "false"
      description: Publish all exposed ports to random ports
      details_url: '#publish-all'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: pull
      value_type: string
      default_value: missing
      description: Pull image before running (`always`, `missing`, `never`)
      details_url: '#pull'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: quiet
      shorthand: q
      value_type: bool
      default_value: "false"
      description: Suppress the pull output
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: read-only
      value_type: bool
      default_value: "false"
      description: Mount the container's root filesystem as read only
      details_url: '#read-only'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: restart
      value_type: string
      default_value: "no"
      description: Restart policy to apply when a container exits
      details_url: '#restart'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: rm
      value_type: bool
      default_value: "false"
      description: |
        Automatically remove the container and its associated anonymous volumes when it exits
      details_url: '#rm'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: runtime
      value_type: string
      description: Runtime to use for this container
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: security-opt
      value_type: list
      description: Security Options
      details_url: '#security-opt'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: shm-size
      value_type: bytes
      default_value: "0"
      description: Size of /dev/shm
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: sig-proxy
      value_type: bool
      default_value: "true"
      description: Proxy received signals to the process
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: stop-signal
      value_type: string
      description: Signal to stop the container
      details_url: '#stop-signal'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: stop-timeout
      value_type: int
      default_value: "0"
      description: Timeout (in seconds) to stop a container
      details_url: '#stop-timeout'
      deprecated: false
      hidden: false
      min_api_version: "1.25"
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: storage-opt
      value_type: list
      description: Storage driver options for the container
      details_url: '#storage-opt'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: sysctl
      value_type: map
      default_value: map[]
      description: Sysctl options
      details_url: '#sysctl'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: tmpfs
      value_type: list
      description: Mount a tmpfs directory
      details_url: '#tmpfs'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: tty
      shorthand: t
      value_type: bool
      default_value: "false"
      description: Allocate a pseudo-TTY
      details_url: '#tty'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: ulimit
      value_type: ulimit
      default_value: '[]'
      description: Ulimit options
      details_url: '#ulimit'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: use-api-socket
      value_type: bool
      default_value: "false"
      description: Bind mount Docker API socket and required auth
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: user
      shorthand: u
      value_type: string
      description: 'Username or UID (format: <name|uid>[:<group|gid>])'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: userns
      value_type: string
      description: User namespace to use
      details_url: '#userns'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: uts
      value_type: string
      description: UTS namespace to use
      details_url: '#uts'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: volume
      shorthand: v
      value_type: list
      description: Bind mount a volume
      details_url: '#volume'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: volume-driver
      value_type: string
      description: Optional volume driver for the container
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: volumes-from
      value_type: list
      description: Mount volumes from the specified container(s)
      details_url: '#volumes-from'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
    - option: workdir
      shorthand: w
      value_type: string
      description: Working directory inside the container
      details_url: '#workdir'
      deprecated: false
      hidden: false
      experimental: false
      experimentalcli: false
      kubernetes: false
      swarm: false
examples: |-
    ### 指定容器名称 (--name) {#name}

    使用 `--name` 可以为容器指定自定义名称。下面的示例使用 `nginx:alpine` 镜像
    以[分离模式](#detach)运行一个名为 `test` 的容器：

    ```console
    $ docker run --name test -d nginx:alpine
    4bed76d3ad428b889c56c1ecc2bf2ed95cb08256db22dc5ef5863e1d03252a19
    $ docker ps
    CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS                  PORTS     NAMES
    4bed76d3ad42   nginx:alpine   "/docker-entrypoint.…"   1 second ago   Up Less than a second   80/tcp    test
    ```

    之后你可以在其他命令中直接通过名称引用该容器。比如，下面的命令会停止并删除名为 `test` 的容器：

    ```console
    $ docker stop test
    test
    $ docker rm test
    test
    ```

    如果未通过 `--name` 指定自定义名称，守护进程会为容器分配一个随机名称（例如 `vibrant_cannon`）。
    自定义名称可以让容器更易于识别与记忆。

    此外，如果你将容器连接到用户自定义的桥接网络，同一网络中的其他容器可以通过内置 DNS
    直接使用容器名称进行访问。

    ```console
    $ docker network create mynet
    cb79f45948d87e389e12013fa4d969689ed2c3316985dd832a43aaec9a0fe394
    $ docker run --name test --net mynet -d nginx:alpine
    58df6ecfbc2ad7c42d088ed028d367f9e22a5f834d7c74c66c0ab0485626c32a
    $ docker run --net mynet busybox:latest ping test
    PING test (172.18.0.2): 56 data bytes
    64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.073 ms
    64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.411 ms
    64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.319 ms
    64 bytes from 172.18.0.2: seq=3 ttl=64 time=0.383 ms
    ...
    ```

    ### 记录容器 ID (--cidfile) {#cidfile}

    为了便于自动化，你可以让 Docker 将容器 ID 写入到你指定的文件中。
    这与某些程序把进程 ID 写入文件（PID 文件）的做法类似：

    ```console
    $ docker run --cidfile /tmp/docker_test.cid ubuntu echo "test"
    ```

    上述命令会创建一个容器，并在控制台打印 `test`。`--cidfile` 会让 Docker 尝试创建一个新文件，
    并把容器 ID 写入其中；如果文件已存在，Docker 会返回错误。`docker run` 结束时，该文件句柄会被关闭。

    ### PID 设置 (--pid) {#pid}

    ```text
    --pid=""  : Set the PID (Process) Namespace mode for the container,
                 'container:<name|id>': joins another container's PID namespace
                 'host': use the host's PID namespace inside the container
    ```

    默认情况下，所有容器都会启用 PID 命名空间。

    PID 命名空间用于隔离进程视图。它会屏蔽系统中的其他进程，使容器内只看到自身的进程，
    并允许进程 ID（包括 PID 1）在不同命名空间内复用。

    在某些场景下，你可能希望容器与宿主机共享进程命名空间，使容器内可以看到宿主机上的所有进程。
    例如，你可以构建一个包含 `strace` 或 `gdb` 等调试工具的容器，用于对宿主机上的进程进行调试。

    #### 示例：在容器内运行 htop

    在与宿主机共享进程命名空间的容器内运行 `htop`：

    1. 使用 `--pid=host` 启动一个 Alpine 容器：

       ```console
       $ docker run --rm -it --pid=host alpine
       ```

    2. 在容器内安装 `htop`：

       ```console
       / # apk add --quiet htop
       ```

    3. 运行 `htop` 命令。

       ```console
       / # htop
       ```

    #### 示例：加入另一个容器的 PID 命名空间

    加入其他容器的 PID 命名空间有助于调试该容器。

    1. 启动一个运行 Redis 服务的容器：

       ```console
       $ docker run --rm --name my-nginx -d nginx:alpine
       ```

    2. 启动一个 Alpine 容器，并将其 `--pid` 命名空间附加到 `my-nginx` 容器：

       ```console
       $ docker run --rm -it --pid=container:my-nginx \
         --cap-add SYS_PTRACE \
         --security-opt seccomp=unconfined \
         alpine
       ```

    3. 在 Alpine 容器内安装 `strace`：

       ```console
       / # apk add strace
       ```

    4. 附加到进程 1（即 `my-nginx` 容器中的 PID 1）：

       ```console
       / # strace -p 1
       strace: Process 1 attached
       ```

    ### 为单个容器禁用用户命名空间重映射 (--userns) {#userns}

    如果你在守护进程上启用了用户命名空间，所有容器默认会启用用户命名空间。
    若要对某个特定容器禁用用户命名空间重映射，可将 `--userns` 设置为 `host`。

    ```console
    docker run --userns=host hello-world
    ```

    `host` 是 `--userns` 的唯一有效取值。

    了解更多，请参阅[使用用户命名空间隔离容器](/engine/security/userns-remap/)。

    ### UTS 设置 (--uts) {#uts}

    ```text
    --uts=""  : Set the UTS namespace mode for the container
                'host': use the host's UTS namespace inside the container
    ```

    UTS 命名空间用于控制命名空间内进程可见的主机名与域名。默认情况下，所有容器（包括使用 `--network=host` 的容器）
    都拥有各自独立的 UTS 命名空间。将 `--uts` 设置为 `host` 会让容器使用与宿主机相同的 UTS 命名空间。

    > [!NOTE]
    > Docker 不允许将 `--hostname`、`--domainname` 与 `--uts=host` 同时使用。
    > 这是为了防止运行在宿主机 UTS 命名空间中的容器尝试修改宿主机配置。

    如果你希望容器的主机名能随宿主机主机名变化而变化，可能会选择与宿主机共享 UTS 命名空间。
    更高级的用法是从容器中修改宿主机的主机名。

    ### IPC 设置 (--ipc) {#ipc}

    ```text
    --ipc="MODE"  : Set the IPC mode for the container
    ```

    `--ipc` 接受以下取值：

    | 值                         | 说明                                                                              |
    |:---------------------------|:----------------------------------------------------------------------------------|
    | ""                         | 使用守护进程默认值。                                                              |
    | "none"                     | 独立 IPC 命名空间，且不挂载 /dev/shm。                                            |
    | "private"                  | 独立 IPC 命名空间。                                                                |
    | "shareable"                | 独立 IPC 命名空间，并允许与其他容器共享。                                         |
    | "container:<_name-or-ID_>" | 加入另一个（需为 "shareable"）容器的 IPC 命名空间。                               |
    | "host"                     | 使用宿主机的 IPC 命名空间。                                                        |

    如未指定，将使用守护进程默认值；该默认值可能是 `"private"` 或 `"shareable"`，取决于守护进程版本与配置。

    [System V interprocess communication (IPC)](https://linux.die.net/man/5/ipc)
    命名空间会隔离具名共享内存段、信号量与消息队列。

    共享内存段可在“内存速度”下加速进程间通信，而非通过管道或网络栈。
    共享内存在数据库与自研的高性能应用（通常是 C/OpenMPI、C++/Boost 等）中非常常见，
    广泛用于科研计算与金融场景。若这类应用被拆分到多个容器中，你可能需要在容器间共享 IPC 机制：
    为“主”（即“donor”）容器使用 `"shareable"`，为其他容器使用 `"container:<donor-name-or-ID>"`。

    ### 提升容器权限 (--privileged) {#privileged}

    `--privileged` 会为容器授予以下能力：

    - 启用全部 Linux 内核能力（capabilities）
    - 禁用默认的 seccomp 配置
    - 禁用默认的 AppArmor 配置
    - 禁用 SELinux 进程标签
    - 允许访问宿主机上的所有设备
    - 将 `/sys` 挂载为可读写
    - 将 cgroups 挂载为可读写

    换言之，容器几乎可以做宿主机能做的一切。该选项主要用于特殊场景，例如在容器内运行 Docker。

    > [!WARNING]
    > 谨慎使用 `--privileged`。
    > 处于该模式的容器并非安全沙箱，可能获取宿主机的 root shell 并接管系统。
    >
    > 在大多数情况下，不应优先选择该选项；若确需提升权限，更推荐按需授权，
    > 例如使用 `--cap-add` 添加所需的内核能力。
    >
    > 详见[运行时权限与 Linux 能力](/engine/containers/run/#runtime-privilege-and-linux-capabilities)。
    { .warning }

    下面的示例会失败，因为 Docker 默认会移除大多数潜在危险的内核能力，
    包括挂载文件系统所需的 `CAP_SYS_ADMIN`：

    ```console
    $ docker run -t -i --rm ubuntu bash
    root@bc338942ef20:/# mount -t tmpfs none /mnt
    mount: permission denied
    ```

    当添加 `--privileged` 选项后，命令即可成功：

    ```console
    $ docker run -t -i --privileged ubuntu bash
    root@50e3f57e16e6:/# mount -t tmpfs none /mnt
    root@50e3f57e16e6:/# df -h
    Filesystem      Size  Used Avail Use% Mounted on
    none            1.9G     0  1.9G   0% /mnt
    ```

    ### 设置工作目录 (-w, --workdir) {#workdir}

    ```console
    $ docker run -w /path/to/dir/ ubuntu pwd
    ```

    `-w` 会在指定目录中执行命令（此处为 `/path/to/dir/`）。若路径不存在，Docker 会在容器内创建该路径。

    ### 为单个容器设置存储驱动选项 (--storage-opt) {#storage-opt}

    ```console
    $ docker run -it --storage-opt size=120G fedora /bin/bash
    ```

    上述 `size` 会在创建时将容器文件系统限制为 120G。
    此选项仅适用于 `btrfs`、`overlay2`、`windowsfilter` 与 `zfs` 存储驱动。

    对于 `overlay2`，仅当后端文件系统为 `xfs` 且以 `pquota` 选项挂载时，才支持 `size`。
    在此条件下，可设置的大小上限为后端文件系统大小。

    对于 `windowsfilter`、`btrfs` 与 `zfs`，不可设置小于默认 BaseFS 大小的值。

    ### 挂载 tmpfs (--tmpfs) {#tmpfs}

    使用 `--tmpfs` 可以创建一个 `tmpfs` 挂载。

    传给 `--tmpfs` 的选项与 Linux 的 `mount -t tmpfs -o` 命令一致。
    下例演示以 `rw`、`noexec`、`nosuid`、`size=65536k` 选项挂载一个空的 `tmpfs`：

    ```console
    $ docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image
    ```

    详见 [tmpfs 挂载](/storage/tmpfs/)。

    ### 挂载卷 (-v) {#volume}

    ```console
    $ docker  run  -v $(pwd):$(pwd) -w $(pwd) -i -t  ubuntu pwd
    ```

    上述示例将当前目录以相同路径挂载进容器，并将其设置为工作目录，然后在容器内执行 `pwd`。

    从 Docker Engine 23 起，宿主机可使用相对路径。

    ```console
    $ docker  run  -v ./content:/content -w /content -i -t  ubuntu pwd
    ```

    上述示例将当前目录下的 `content` 挂载到容器内的 `/content`，并设置为工作目录，随后执行 `pwd`。

    ```console
    $ docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash
    ```

    当绑定挂载的宿主机目录不存在时，Docker 会在宿主机上自动创建该目录。
    在上述示例中，Docker 会在启动容器前创建 `/doesnt/exist` 目录。

    ### 以只读方式挂载卷 (--read-only) {#read-only}

    ```console
    $ docker run --read-only -v /icanwrite busybox touch /icanwrite/here
    ```

    可将卷与 `--read-only` 一起使用来控制容器的写入位置。
    `--read-only` 会把容器的根文件系统以只读方式挂载，
    从而禁止除已挂载卷以外的位置进行写入。

    ```console
    $ docker run -t -i -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/static-docker-binary:/usr/bin/docker busybox sh
    ```

    若将 Docker 的 Unix 套接字与静态链接的 Docker 二进制（参见[获取 Linux 二进制](/engine/install/binaries/#install-static-binaries)）
    绑定挂载到容器中，就等于赋予容器对宿主机 Docker 守护进程的完全控制权。

    在 Windows 上，必须使用 Windows 风格的路径语法指定路径。

    ```powershell
    PS C:\> docker run -v c:\foo:c:\dest microsoft/nanoserver cmd /s /c type c:\dest\somefile.txt
    Contents of file

    PS C:\> docker run -v c:\foo:d: microsoft/nanoserver cmd /s /c type d:\somefile.txt
    Contents of file
    ```

    以下示例在 Windows 容器中会失败，因为在容器内卷或绑定挂载的目标路径必须满足：
    目标要么是不存在或空目录；要么是 `C:` 以外的盘符。
    另外，绑定挂载的源必须是本地目录而非文件。

    ```powershell
    net use z: \\remotemachine\share
    docker run -v z:\foo:c:\dest ...
    docker run -v \\uncpath\to\directory:c:\dest ...
    docker run -v c:\foo\somefile.txt:c:\dest ...
    docker run -v c:\foo:c: ...
    docker run -v c:\foo:c:\existing-directory-with-contents ...
    ```

    更多卷的使用细节，请参阅[在容器中管理数据](/storage/volumes/)

    ### 使用 --mount 添加绑定挂载或卷 {#mount}

    `--mount` 可在容器中挂载卷、宿主机目录以及 `tmpfs`。

    它支持大多数 `-v`/`--volume` 的选项，但使用不同语法。
    详见[绑定挂载](/storage/bind-mounts/)，其中也包含 `--volume` 与 `--mount` 的对比。

    虽然目前没有弃用 `--volume` 的计划，但建议优先使用 `--mount`。

    示例：

    ```console
    $ docker run --read-only --mount type=volume,target=/icanwrite busybox touch /icanwrite/here
    ```

    ```console
    $ docker run -t -i --mount type=bind,src=/data,dst=/data busybox sh
    ```

    ### 发布或暴露端口 (-p, --expose) {#publish}

    ```console
    $ docker run -p 127.0.0.1:80:8080/tcp nginx:alpine
    ```

    这会将容器的 `8080` 端口绑定到宿主机 `127.0.0.1` 的 TCP `80` 端口。
    你也可以指定 `udp` 与 `sctp` 端口。端口发布的更多细节见[网络概览](/network/)。

    > [!NOTE]
    > 如果在发布端口时未指定 IP（例如使用 `-p 80:80` 而不是 `-p 127.0.0.1:80:80`），
    > Docker 会默认在所有接口（`0.0.0.0`）上发布该端口，使其可从外部访问。
    > 即使你使用 UFW 阻止了该端口，Docker 仍会根据自身的 iptables 规则进行管理。
    > 详见[进一步说明](/network/packet-filtering-firewalls/)

    ```console
    $ docker run --expose 80 nginx:alpine
    ```

    这会仅在容器内声明暴露 `80` 端口，但不会将其发布到宿主机接口。

    ### 发布所有暴露的端口 (-P, --publish-all) {#publish-all}

    ```console
    $ docker run -P nginx:alpine
    ```

    使用 `-P`（或 `--publish-all`）会将所有已暴露的端口发布到宿主机，
    Docker 会把每个暴露端口绑定到宿主机的随机端口。

    `-P` 仅会发布那些显式“暴露”的端口（来自 Dockerfile 的 `EXPOSE` 指令，或 `docker run` 的 `--expose`）。

    端口范围位于 `/proc/sys/net/ipv4/ip_local_port_range` 定义的“临时端口范围”内。
    如需显式映射某个端口或端口区间，请使用 `-p`。

    ### 设置拉取策略 (--pull) {#pull}

    在创建（并运行）容器时，可使用 `--pull` 指定镜像拉取策略。

    `--pull` 可取如下值：

    | 取值                | 说明                                                                                                              |
    |:--------------------|:------------------------------------------------------------------------------------------------------------------|
    | `missing`（默认）   | 若本地镜像缓存不存在，则拉取；否则使用缓存镜像。                                                                |
    | `never`             | 即使本地缺失也不拉取；若缓存中找不到镜像则报错。                                                                  |
    | `always`            | 在创建容器前总是先拉取镜像。                                                                                      |

    When creating (and running) a container from an image, the daemon checks if the
    image exists in the local image cache. If the image is missing, an error is
    returned to the CLI, allowing it to initiate a pull.

    The default (`missing`) is to only pull the image if it's not present in the
    daemon's image cache. This default allows you to run images that only exist
    locally (for example, images you built from a Dockerfile, but that have not
    been pushed to a registry), and reduces networking.

    The `always` option always initiates a pull before creating the container. This
    option makes sure the image is up-to-date, and prevents you from using outdated
    images, but may not be suitable in situations where you want to test a locally
    built image before pushing (as pulling the image overwrites the existing image
    in the image cache).

    The `never` option disables (implicit) pulling images when creating containers,
    and only uses images that are available in the image cache. If the specified
    image is not found, an error is produced, and the container is not created.
    This option is useful in situations where networking is not available, or to
    prevent images from being pulled implicitly when creating containers.

    下面的示例展示了设置 `--pull=never` 时的行为；由于镜像在本地缓存中缺失，将产生错误：

    ```console
    $ docker run --pull=never hello-world
    docker: Error response from daemon: No such image: hello-world:latest.
    ```

    ### 设置环境变量 (-e, --env, --env-file) {#env}

    ```console
    $ docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash
    ```

    使用 `-e`、`--env` 与 `--env-file` 可以为容器设置简单（非数组）环境变量，
    或覆盖镜像 Dockerfile 中定义的变量。

    你可以在运行容器时直接定义变量和值：

    ```console
    $ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR
    VAR1=value1
    VAR2=value2
    ```

    也可以使用本地环境中已导出的变量：

    ```console
    export VAR1=value1
    export VAR2=value2

    $ docker run --env VAR1 --env VAR2 ubuntu env | grep VAR
    VAR1=value1
    VAR2=value2
    ```

    执行命令时，CLI 会读取本地环境中的变量值并传入容器。
    如果未提供 `=` 且该变量未在本地导出，则在容器中该变量为空（未设置）。

    还可以从文件中加载环境变量。文件格式支持 `<variable>=value`（设置为给定值）或 `<variable>`（从本地环境取值），
    `#` 表示注释。以 `#` 开头的行会被忽略；行中其他位置出现的 `#` 会被视为值的一部分。

    ```console
    $ cat env.list
    # This is a comment
    VAR1=value1
    VAR2=value2
    USER

    $ docker run --env-file env.list ubuntu env | grep -E 'VAR|USER'
    VAR1=value1
    VAR2=value2
    USER=jonzeolla
    ```

    ### 设置容器元数据 (-l, --label, --label-file) {#label}

    标签是应用于容器的 `key=value` 键值对。下面示例为容器添加两个标签：

    ```console
    $ docker run -l my-label --label com.example.foo=bar ubuntu bash
    ```

    `my-label` 未指定值，因此其值默认为空字符串（`""`）。如需添加多个标签，可重复使用 `-l` 或 `--label`。

    `key=value` 的键名应保持唯一，以避免被后续同键标签覆盖；如同键多次赋值，Docker 采用最后一次的值。

    使用 `--label-file` 可从文件中加载多个标签。文件中每个标签以换行分隔：

    ```console
    $ docker run --label-file ./labels ubuntu bash
    ```

    标签文件的格式与环境变量文件类似（不同的是，标签对容器内的进程不可见）。例如：

    ```console
    com.example.label1="a label"

    # this is a comment
    com.example.label2=another\ label
    com.example.label3
    ```

    可通过多次提供 `--label-file` 来加载多个标签文件。

    更多用法参见[标签](/config/labels-custom-metadata/)。

    ### 将容器连接到网络 (--network) {#network}

    使用 `--network` 可以在启动容器时将其连接到某个网络。

    若要将一个已运行的容器加入网络，请使用 `docker network connect` 子命令。

    你可以把多个容器连接到同一网络。连接后，容器之间可以通过彼此的 IP 或名称进行通信。
    对于 `overlay` 网络或支持多主机连通性的插件，即便容器运行在不同的 Engine 上，只要处于同一多主机网络中，也能互通。

    > [!NOTE]
    > 默认的 bridge 网络仅允许容器通过内网 IP 互通。
    > 用户自定义的 bridge 网络则提供基于容器名称的 DNS 解析。

    可使用 `docker network disconnect` 将容器从网络中断开。

    下列命令会创建一个名为 `my-net` 的网络，并将一个 `busybox` 容器连接到该网络：

    ```console
    $ docker network create my-net
    $ docker run -itd --network=my-net busybox
    ```

    在用户自定义网络上启动容器时，你还可以通过 `--ip` 与 `--ip6` 指定容器的 IP 地址。
    若要分配静态 IP，必须为网络指定子网段：

    ```console
    $ docker network create --subnet 192.0.2.0/24 my-net
    $ docker run -itd --network=my-net --ip=192.0.2.69 busybox
    ```

    如需连接到多个网络，可重复使用 `--network` 选项：

    ```console
    $ docker network create --subnet 192.0.2.0/24 my-net1
    $ docker network create --subnet 192.0.3.0/24 my-net2
    $ docker run -itd --network=my-net1 --network=my-net2 busybox
    ```

    当需要同时连接多个网络并分别指定选项时，可使用 `--network` 的扩展语法（逗号分隔）：

    | 选项            | 顶层等价项                            | 说明                                                                                    |
    |-----------------|---------------------------------------|-----------------------------------------------------------------------------------------|
    | `name`          |                                       | 网络名称（必填）                                                                        |
    | `alias`         | `--network-alias`                     | 为容器添加网络作用域的别名                                                              |
    | `ip`            | `--ip`                                | IPv4 地址（例如 172.30.100.104）                                                         |
    | `ip6`           | `--ip6`                               | IPv6 地址（例如 2001:db8::33）                                                           |
    | `mac-address`   | `--mac-address`                       | 容器 MAC 地址（例如 92:d0:c6:0a:29:33）                                                  |
    | `link-local-ip` | `--link-local-ip`                     | 容器的 IPv4/IPv6 链路本地地址                                                           |
    | `driver-opt`    | `docker network connect --driver-opt` | 网络驱动选项                                                                            |
    | `gw-priority`   |                                       | 网关优先级。较高者作为默认网关；可取正数或负数。                                         |

    ```console
    $ docker network create --subnet 192.0.2.0/24 my-net1
    $ docker network create --subnet 192.0.3.0/24 my-net2
    $ docker run -itd --network=name=my-net1,ip=192.0.2.42 --network=name=my-net2,ip=192.0.3.42 busybox
    ```

    以 `net.ipv4.`、`net.ipv6.` 或 `net.mpls.` 开头的 `sysctl` 可通过 `driver-opt`
    标签 `com.docker.network.endpoint.sysctls` 按接口进行设置。接口名固定为字符串 `IFNAME`。

    若要为某接口设置多个 `sysctl`，请整体引用 `driver-opt` 字段（必要时为 shell 转义引号）。
    例如接口名为 `eth0` 时，下面示例设置 `net.ipv4.conf.eth0.log_martians=1` 与
    `net.ipv4.conf.eth0.forwarding=0`，同时分配 IPv4 地址 `192.0.2.42`：

    ```console
    $ docker network create --subnet 192.0.2.0/24 my-net
    $ docker run -itd --network=name=my-net,\"driver-opt=com.docker.network.endpoint.sysctls=net.ipv4.conf.IFNAME.log_martians=1,net.ipv4.conf.IFNAME.forwarding=0\",ip=192.0.2.42 busybox
    ```

    > [!NOTE]
    > 网络驱动可能会限制可修改的 sysctl 项；为保护网络运行，未来也可能新增限制。

    使用 `run` 连接容器到网络的更多信息，参阅[网络概览](/network/)。

    ### 从其他容器挂载卷 (--volumes-from) {#volumes-from}

    ```console
    $ docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu pwd
    ```

    `--volumes-from` 会挂载被引用容器上定义的全部卷。可多次使用 `--volumes-from` 指定多个容器。
    容器 ID 可带上 `:ro` 或 `:rw` 后缀，分别以只读或读写方式挂载这些卷。
    默认情况下，会沿用被引用容器上的挂载模式。

    类似 SELinux 的标记系统要求为挂载进容器的卷内容设置合适的标签。
    否则安全系统可能会阻止容器内的进程访问这些内容。Docker 默认不会修改操作系统设置的标签。

    如需在容器上下文中调整标签，可在卷挂载后缀添加 `:z` 或 `:Z`：
    `:z` 表示卷会被多个容器共享，Docker 会使用“共享”标签；
    `:Z` 表示卷是私有的，仅当前容器可用，Docker 会使用“私有”标签。

    ### Detached mode (-d, --detach) {#detach}

    The `--detach` (or `-d`) flag starts a container as a background process that
    doesn't occupy your terminal window. By design, containers started in detached
    mode exit when the root process used to run the container exits, unless you
    also specify the `--rm` option. If you use `-d` with `--rm`, the container is
    removed when it exits or when the daemon exits, whichever happens first.

    Don't pass a `service x start` command to a detached container. For example,
    this command attempts to start the `nginx` service.

    ```console
    $ docker run -d -p 80:80 my_image service nginx start
    ```

    上述命令虽然在容器内启动了 `nginx` 服务，但违背了“分离模式”的范式：
    根进程（`service nginx start`）很快退出，容器也随之按设计停止，导致服务无法使用。
    正确的做法是让服务以前台方式运行，例如：

    ```console
    $ docker run -d -p 80:80 my_image nginx -g 'daemon off;'
    ```

    若要与分离模式容器交互 I/O，请通过网络连接或共享卷进行；
    这是因为容器不再监听执行 `docker run` 的终端。

    ### 覆盖分离按键序列 (--detach-keys) {#detach-keys}

    使用 `--detach-keys` 可自定义从容器分离的按键序列。
    当 Docker 默认序列与其他应用的快捷键冲突时，这很有用。
    你可以为单个容器覆盖设置，也可以在配置文件中设置全局默认。

    为单个容器覆盖设置时，可在 `docker attach` 搭配 `--detach-keys="<sequence>"`：
    `<sequence>` 可以是单个字母 [a-Z]，或 `ctrl-` 加上以下任意之一：

    * `a-z` (a single lowercase alpha character )
    * `@` (at sign)
    * `[` (left bracket)
    * `\\` (two backward slashes)
    *  `_` (underscore)
    * `^` (caret)

    上述如 `a`、`ctrl-a`、`X`、`ctrl-\\` 等都属于合法序列。
    若要设置全局默认分离键，请参阅[配置文件](/reference/cli/docker/#configuration-files)。

    ### 向容器添加宿主机设备 (--device) {#device}

    ```console
    $ docker run -it --rm \
        --device=/dev/sdc:/dev/xvdc \
        --device=/dev/sdd \
        --device=/dev/zero:/dev/foobar \
        ubuntu ls -l /dev/{xvdc,sdd,foobar}

    brw-rw---- 1 root disk 8, 2 Feb  9 16:05 /dev/xvdc
    brw-rw---- 1 root disk 8, 3 Feb  9 16:05 /dev/sdd
    crw-rw-rw- 1 root root 1, 5 Feb  9 16:05 /dev/foobar
    ```

    需要时可以直接把设备暴露给容器，`--device` 用于此目的。
    例如，将某个块设备、回环设备或音频设备添加给一个并未启用 `--privileged` 的容器，
    让应用程序可直接访问该设备。

    默认情况下，容器对这些设备拥有 `read`、`write`、`mknod` 权限。
    可在 `--device` 末尾添加第三段 `:rwm` 来覆盖权限。
    若容器处于 privileged 模式，Docker 会忽略此处权限设置。

    ```console
    $ docker run --device=/dev/sda:/dev/xvdc --rm -it ubuntu fdisk  /dev/xvdc

    Command (m for help): q
    $ docker run --device=/dev/sda:/dev/xvdc:r --rm -it ubuntu fdisk  /dev/xvdc
    You will not be able to write the partition table.

    Command (m for help): q

    $ docker run --device=/dev/sda:/dev/xvdc:rw --rm -it ubuntu fdisk  /dev/xvdc

    Command (m for help): q

    $ docker run --device=/dev/sda:/dev/xvdc:m --rm -it ubuntu fdisk  /dev/xvdc
    fdisk: unable to open /dev/xvdc: Operation not permitted
    ```

    > [!NOTE]
    > `--device` 不适合用于临时设备；不要将可能被移除的块设备通过 `--device` 暴露给不受信任的容器。

    在 Windows 上，`--device` 参数格式为 `--device=<IdType>/<Id>`。
    自 Windows Server 2019 与 Windows 10 2018 年 10 月更新起，仅支持 `IdType=class`，
    且 Id 为[设备接口类 GUID](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/overview-of-device-interface-classes)。
    受支持的 GUID 列表见[Windows 容器文档](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/hardware-devices-in-containers)。

    对于进程隔离（process-isolated）的 Windows 容器，指定该选项会将实现所请求接口类 GUID 的“所有设备”暴露给容器。
    例如下列命令会让宿主机的全部 COM 端口在容器内可见：

    ```powershell
    PS C:\> docker run --device=class/86E0D1E0-8089-11D0-9CE4-08003E301F73 mcr.microsoft.com/windows/servercore:ltsc2019
    ```

    > [!NOTE]
    > `--device` 仅支持进程隔离的 Windows 容器；若容器隔离为 `hyperv` 将报错。

    #### CDI 设备

    [容器设备接口（CDI）](https://github.com/cncf-tags/container-device-interface/blob/main/SPEC.md)
    是一套标准机制，使容器运行时能创建可与第三方设备交互的容器。

    目前 CDI 仅支持 Linux 容器，自 Docker Engine 28.3.0 起默认启用。

    在 CDI 中，设备通过 JSON/YAML 进行声明式配置。
    除了让容器可访问设备节点外，还可声明设备的附加配置，如环境变量、宿主机挂载（共享库等）与可执行 hooks。

    你可以通过 `--device` 使用设备的完全限定名来引用 CDI 设备，例如：

    ```console
    $ docker run --device=vendor.com/class=device-name --rm -it ubuntu
    ```

    这将启动一个可访问指定 CDI 设备（`vendor.com/class=device-name`）的 `ubuntu` 容器，前提是：

    - 运行守护进程的系统已在配置的 CDI 目录中提供了该设备的有效 CDI 规范（JSON/YAML）。
    - 守护进程已启用 CDI 功能；见[启用 CDI 设备](/reference/cli/dockerd/#configure-cdi-devices)。

    ### 附加到标准流 (-a, --attach) {#attach}

    使用 `--attach`（或 `-a`）可以让 `docker run` 附加到容器的 `STDIN`、`STDOUT` 或 `STDERR`，
    以便按需处理输入输出。你可以选择附加到哪个标准流，例如：

    ```console
    $ docker run -a stdin -a stdout -i -t ubuntu /bin/bash
    ```

    下面示例仅附加到 `STDIN`，将数据通过管道传入容器，并输出容器 ID：

    ```console
    $ echo "test" | docker run -i -a stdin ubuntu cat -
    ```

    下面示例只附加 `STDERR`，因此除非有错误，否则不会在控制台输出内容；
    写入到 `STDIN`/`STDOUT` 的内容仍可通过容器日志获取。

    ```console
    $ docker run -a stderr ubuntu echo test
    ```

    下面示例展示了如何用 `--attach` 将文件通过管道传入容器：构建完成后打印容器 ID，
    随后可通过 `docker logs` 获取构建日志。

    ```console
    $ cat somefile | docker run -i -a stdin mybuilder dobuild
    ```

    > [!NOTE]
    > 作为容器内 PID 1 运行的进程在 Linux 下会被特殊对待：
    > 对默认动作的信号会被忽略。因此，除非程序专门处理，收到 `SIGINT` 或 `SIGTERM` 时不会退出。

    另见 [`docker cp`](/reference/cli/docker/container/cp/)。

    ### 保持 STDIN 打开 (-i, --interactive) {#interactive}

    使用 `--interactive`（或 `-i`）可保持容器的 `STDIN` 打开，
    从而通过标准输入向容器发送数据。

    ```console
    $ echo hello | docker run --rm -i busybox cat
    hello
    ```

    `-i` 通常与 `--tty` 一起使用，将容器的 I/O 绑定到伪终端，创建交互式会话；
    更多示例见[分配伪 TTY](#tty)。

    ```console
    $ docker run -it debian
    root@10a3e71492b0:/# factor 90
    90: 2 3 3 5
    root@10a3e71492b0:/# exit
    exit
    ```

    单独使用 `-i` 也便于进行命令组合，例如通过管道把输出依次传入多个容器：

    ```console
    $ docker run --rm -i busybox echo "foo bar baz" \
      | docker run --rm -i busybox awk '{ print $2 }' \
      | docker run --rm -i busybox rev
    rab
    ```

    ### 指定 init 进程 {#init}

    使用 `--init` 可以让容器以一个 init 进程作为 PID 1，
    以确保“回收僵尸进程”等 init 系统的职责在容器内正常进行。

    默认的 init 进程是守护进程系统路径中找到的第一个 `docker-init` 可执行文件。
    该二进制随默认安装提供，底层由 [tini](https://github.com/krallin/tini) 提供支持。

    ### 分配伪终端 (-t, --tty) {#tty}

    使用 `--tty`（或 `-t`）会为容器分配一个伪 TTY，使你的终端连接到容器的 I/O 流，
    从而获得 TTY 设备提供的输入输出特性。

    例如，下列命令在 `debian` 容器中运行 `passwd`，为 `root` 用户设置新密码：

    ```console
    $ docker run -i debian passwd root
    New password: karjalanpiirakka9
    Retype new password: karjalanpiirakka9
    passwd: password updated successfully
    ```

    若仅使用 `-i`（只保留输入），`passwd` 会在提示中显示明文输入；
    同样的命令加上 `-t` 后，输入将被隐藏：

    ```console
    $ docker run -it debian passwd root
    New password:
    Retype new password:
    passwd: password updated successfully
    ```

    这是因为 `passwd` 借助 TTY 的“关闭回显”特性抑制了字符输出。

    你也可以仅使用 `-t` 而不带 `-i`；此时仍会分配伪 TTY，但无法向 `STDIN` 写入，
    仅在容器输出需要 TTY 环境时有用。

    ### 指定自定义 cgroup {#cgroup-parent}

    使用 `--cgroup-parent` 可以将容器放入指定的 cgroup 中运行。
    这允许你自行创建与管理 cgroup，为其定义资源限制，并将多个容器置于同一父组下。

    ### 使用动态创建设备规则 (--device-cgroup-rule) {#device-cgroup-rule}

    Docker 会在容器创建时分配可用设备，并将其写入 cgroup.allow，容器运行时据此创建设备节点。
    这在需要为“已在运行”的容器添加新设备时会带来问题。

    一种解决方式是添加更宽泛的设备规则，允许容器访问更大范围的设备。
    例如，若容器需要访问主设备号为 `42` 的字符设备（次设备号不定，会随新设备增加），可以添加：

    ```console
    $ docker run -d --device-cgroup-rule='c 42:* rmw' --name my-container my-image
    ```

    随后，可让 `udev` 在检测到新设备时执行脚本，在容器内运行 `docker exec my-container mknod newDevX c 42 <minor>` 以创建设备节点。

    > [!NOTE]
    > 初始即存在的设备仍需在 `docker run`/`docker create` 时显式添加。

    ### 访问 NVIDIA GPU {#gpus}

    使用 `--gpus` 可访问 NVIDIA GPU 资源。首先需要安装 [nvidia-container-runtime](https://nvidia.github.io/nvidia-container-runtime/)。

    > [!NOTE]
    > You can also specify a GPU as a CDI device with the `--device` flag, see
    > [CDI devices](#cdi-devices).

    更多信息参见[为容器指定资源](/config/containers/resource_constraints/)。

    使用 `--gpus` 时，可指定使用哪些 GPU（或全部）。若不传值，Docker 将使用所有可用 GPU。下面示例暴露全部 GPU：

    ```console
    $ docker run -it --rm --gpus all ubuntu nvidia-smi
    ```

    使用 `device` 选项可指定具体 GPU，下例暴露特定 GPU：

    ```console
    $ docker run -it --rm --gpus device=GPU-3a23c669-1f69-c64e-cf85-44e9b07e7a2a ubuntu nvidia-smi
    ```

    下例暴露第 1 与第 3 块 GPU：

    ```console
    $ docker run -it --rm --gpus '"device=0,2"' ubuntu nvidia-smi
    ```

    ### 重启策略 (--restart) {#restart}

    使用 `--restart` 指定容器的“重启策略”，控制容器退出后 Docker 守护进程是否重启它。
    支持的策略如下：

    | 选项                       | 说明                                                                                                                                                                                                                                                                                                                                                                   |
    | :------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `no`                       | 不自动重启（默认）。                                                                                                                                                                                                                                                                                                                                                   |
    | `on-failure[:max-retries]` | 当容器因错误退出（非零退出码）时重启。可通过 `:max-retries` 限制最大重试次数。仅在容器失败退出时才会重启；当守护进程自身重启时不会重启容器。                                                                                                                                                                                                                          |
    | `always`                   | 只要容器停止就重启；若被手动停止，则会在守护进程重启后或手动重启容器时再启动。                                                                                                                                                                                                                                                   |
    | `unless-stopped`           | 类似 `always`，但当容器被停止（手动或其他原因）后，即便守护进程重启也不会自动重启该容器。                                                                                                                                                                                                                                         |

    ```console
    $ docker run --restart=always redis
    ```

    以上命令以 **always** 策略运行 `redis`；容器退出后会被自动重启。

    当容器启用了重启策略，在 [`docker ps`](/reference/cli/docker/container/ls/) 中会看到状态为 `Up` 或 `Restarting`。
    也可通过 [`docker events`](/reference/cli/docker/system/events/) 观察重启事件。

    为避免频繁重启导致“风暴”，每次重启前会加入递增的延迟（从 100ms 开始翻倍：100、200、400、800、1600...），
    直到达到 `on-failure` 限制、或最大 1 分钟延迟、或你执行 `docker stop`/`docker rm -f`。

    若容器成功重启（启动并运行至少 10 秒），延迟会重置为 100ms。

    #### 为重启尝试设置上限

    使用 **on-failure** 时可以限制最大重启次数；默认情况下不会停止重试。

    下例以 **on-failure** 策略运行 `redis`，最大重启次数为 10：

    ```console
    $ docker run --restart=on-failure:10 redis
    ```

    如果 `redis` 连续超过 10 次以非零状态退出，Docker 将停止重启。
    最大重启次数仅适用于 **on-failure** 策略。

    #### 查看容器重启情况

    可通过 [`docker inspect`](/reference/cli/docker/inspect/) 获取容器的（尝试）重启次数，例如：

    ```console
    $ docker inspect -f "{{ .RestartCount }}" my-container
    2
    ```

    或查看容器最近一次（重新）启动的时间：

    ```console
    $ docker inspect -f "{{ .State.StartedAt }}" my-container
    2015-03-04T23:47:07.691840179Z
    ```

    将 `--restart` 与 `--rm` 同时使用会报错。
    当容器重启时，已附加到容器的客户端会被断开。

    ### 退出自动清理 (--rm) {#rm}

    默认情况下，即便容器退出，其文件系统仍然保留，这有助于调试（可检查最终状态并保留数据）。

    如果你运行的是短期的“前台”进程，这些文件系统可能会堆积。
    若希望容器退出时自动清理并删除文件系统，请使用 `--rm`：

    ```text
    --rm: Automatically remove the container when it exits
    ```

    > [!NOTE]
    > 设置了 `--rm` 时，Docker 也会一并清理容器关联的匿名卷（类似执行 `docker rm -v my-container`）。
    > 只有未命名的卷会被删除。比如在下面的命令中，会删除 `/foo`，但不会删除 `/bar`：
    >
    > ```console
    > $ docker run --rm -v /foo -v awesome:/bar busybox top
    > ```
    >
    > 通过 `--volumes-from` 继承的卷也遵循同样逻辑：若原卷是命名卷，则不会被删除。

    ### 向容器 hosts 文件添加条目 (--add-host) {#add-host}

    通过一个或多个 `--add-host`，可以向容器的 `/etc/hosts` 添加条目。
    下例为主机名 `my-hostname` 添加静态地址：

    ```console
    $ docker run --add-host=my-hostname=8.8.8.8 --rm -it alpine

    / # ping my-hostname
    PING my-hostname (8.8.8.8): 56 data bytes
    64 bytes from 8.8.8.8: seq=0 ttl=37 time=93.052 ms
    64 bytes from 8.8.8.8: seq=1 ttl=37 time=92.467 ms
    64 bytes from 8.8.8.8: seq=2 ttl=37 time=92.252 ms
    ^C
    --- my-hostname ping statistics ---
    4 packets transmitted, 4 packets received, 0% packet loss
    round-trip min/avg/max = 92.209/92.495/93.052 ms
    ```

    IPv6 地址需要使用方括号包裹：

    ```console
    $ docker run --add-host my-hostname=[2001:db8::33] --rm -it alpine
    ```

    `--add-host` 支持特殊值 `host-gateway`，其会解析为宿主机的内部 IP。
    这在容器需要访问宿主机上的服务时非常有用。

    通常会使用主机名 `host.docker.internal` 来指向 `host-gateway`。
    Docker Desktop 会自动解析该主机名，详见[网络特性](/desktop/features/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host)。

    下例演示 `host-gateway` 的使用：示例在主机上运行 HTTP 服务，并通过 `host.docker.internal`
    （解析为宿主机内部 IP）向容器提供文件：

    ```console
    $ echo "hello from host!" > ./hello
    $ python3 -m http.server 8000
    Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
    $ docker run \
      --add-host host.docker.internal=host-gateway \
      curlimages/curl -s host.docker.internal:8000/hello
    hello from host!
    ```

    `--add-host` 也支持使用 `:` 作为分隔符，例如：

    ```console
    $ docker run --add-host=my-hostname:8.8.8.8 --rm -it alpine
    ```

    ### 日志驱动 (--log-driver) {#log-driver}

    容器可使用与 Docker 守护进程不同的日志驱动。使用 `--log-driver=<DRIVER>` 配置容器的日志驱动。

    支持的日志驱动及其用法参见[配置日志驱动](/engine/logging/configure/)。

    若要禁用容器日志，将 `--log-driver` 设为 `none`：

    ```console
    $ docker run --log-driver=none -d nginx:alpine
    5101d3b7fe931c27c2ba0e65fd989654d297393ad65ae238f20b97a020e7295b
    $ docker logs 5101d3b
    Error response from daemon: configured logging driver does not support reading
    ```

    ### 设置容器内 ulimit (--ulimit) {#ulimit}

    在容器内设置 `ulimit` 需要额外权限（默认容器不具备），可通过 `--ulimit` 指定。
    语法为 `<type>=<soft limit>[:<hard limit>]`，例如：

    ```console
    $ docker run --ulimit nofile=1024:1024 --rm debian sh -c "ulimit -n"
    1024
    ```

    > [!NOTE]
    > 如未指定硬限制值，将使用软限制值作为硬限制；如未提供任何值，将继承守护进程的默认 `ulimits`。

    > [!NOTE]
    > `as` 选项已弃用；因此以下写法不再受支持：
    >
    > ```console
    > $ docker run -it --ulimit as=1024 fedora /bin/bash
    > ```

    #### `--ulimit` 支持的类型：

    | 类型         | 说明                                                      |
    |:-------------|:----------------------------------------------------------|
    | `core`       | Maximum size of core files created (`RLIMIT_CORE`)        |
    | `cpu`        | CPU time limit in seconds (`RLIMIT_CPU`)                  |
    | `data`       | Maximum data segment size (`RLIMIT_DATA`)                 |
    | `fsize`      | Maximum file size (`RLIMIT_FSIZE`)                        |
    | `locks`      | Maximum number of file locks (`RLIMIT_LOCKS`)             |
    | `memlock`    | Maximum locked-in-memory address space (`RLIMIT_MEMLOCK`) |
    | `msgqueue`   | Maximum bytes in POSIX message queues (`RLIMIT_MSGQUEUE`) |
    | `nice`       | Maximum nice priority adjustment (`RLIMIT_NICE`)          |
    | `nofile`     | Maximum number of open file descriptors (`RLIMIT_NOFILE`) |
    | `nproc`      | Maximum number of processes available (`RLIMIT_NPROC`)    |
    | `rss`        | Maximum resident set size (`RLIMIT_RSS`)                  |
    | `rtprio`     | Maximum real-time scheduling priority (`RLIMIT_RTPRIO`)   |
    | `rttime`     | Maximum real-time execution time (`RLIMIT_RTTIME`)        |
    | `sigpending` | Maximum number of pending signals (`RLIMIT_SIGPENDING`)   |
    | `stack`      | Maximum stack size (`RLIMIT_STACK`)                       |

    Docker 直接将这些值传给底层操作系统的 `syscall`，不会进行单位换算，请据此设定数值。

    #### 关于 `nproc`

    谨慎设置 `nproc`：Linux 中它限制的是“用户可用的最大进程数”，而非“容器内的最大进程数”。
    例如，以 `daemon` 用户分别启动 4 个容器：

    ```console
    $ docker run -d -u daemon --ulimit nproc=3 busybox top

    $ docker run -d -u daemon --ulimit nproc=3 busybox top

    $ docker run -d -u daemon --ulimit nproc=3 busybox top

    $ docker run -d -u daemon --ulimit nproc=3 busybox top
    ```

    第 4 个容器会失败，并报错 “System error: resource temporarily unavailable”。
    原因是 `nproc=3` 导致前 3 个容器已经耗尽了用户 `daemon` 的 3 个进程配额。

    ### 以信号停止容器 (--stop-signal) {#stop-signal}

    `--stop-signal` 会向容器发送系统信号以退出。
    信号可以是 `SIG<NAME>`（如 `SIGKILL`），也可以是对应内核信号表位置的无符号数字（如 `9`）。

    默认值由镜像中的 [`STOPSIGNAL`](/reference/dockerfile/#stopsignal) 指令决定；若未定义，则为 `SIGTERM`。

    ### 可选安全选项 (--security-opt) {#security-opt}

    | 选项                                      | 说明                                                                                                                                                                                                             |
    |:------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | `--security-opt="label=user:USER"`        | 设置容器的 SELinux 用户标签                                                                                                                                                                                      |
    | `--security-opt="label=role:ROLE"`        | 设置容器的 SELinux 角色标签                                                                                                                                                                                      |
    | `--security-opt="label=type:TYPE"`        | 设置容器的 SELinux 类型标签                                                                                                                                                                                      |
    | `--security-opt="label=level:LEVEL"`      | 设置容器的 SELinux 等级标签                                                                                                                                                                                      |
    | `--security-opt="label=disable"`          | 关闭容器的 SELinux 标签约束                                                                                                                                                                                      |
    | `--security-opt="apparmor=PROFILE"`       | 为容器应用指定的 AppArmor 配置                                                                                                                                                                                   |
    | `--security-opt="no-new-privileges=true"` | 禁止容器进程获取新的权限                                                                                                                                                                                          |
    | `--security-opt="seccomp=unconfined"`     | 关闭容器的 seccomp 限制                                                                                                                                                                                          |
    | `--security-opt="seccomp=builtin"`        | 使用默认（内置）seccomp 配置；适用于守护进程设置了自定义默认配置或禁用了 seccomp 的场景                                                                                                                            |
    | `--security-opt="seccomp=profile.json"`   | 使用指定的 seccomp JSON 白名单作为过滤器                                                                                                                                                                         |
    | `--security-opt="systempaths=unconfined"` | 关闭对系统路径（masked/read-only）的约束                                                                                                                                                                         |

    `--security-opt` 可覆盖容器的默认标签策略。如下例通过设置 `level` 允许多个容器共享相同内容：

    ```console
    $ docker run --security-opt label=level:s0:c100,c200 -it fedora bash
    ```

    > [!NOTE]
    > 不支持 MLS 标签的自动转换。

    若要完全禁用容器的安全标签，可使用 `label=disable`：

    ```console
    $ docker run --security-opt label=disable -it ubuntu bash
    ```

    如果需要更严格的安全策略，可指定自定义的 `type` 标签。如下例仅允许容器监听 Apache 相关端口：

    ```console
    $ docker run --security-opt label=type:svirt_apache_t -it ubuntu bash
    ```

    > [!NOTE]
    > 你需要自行编写策略来定义 `svirt_apache_t` 类型。

    如需阻止容器进程提升权限，可使用：

    ```console
    $ docker run --security-opt no-new-privileges -it ubuntu bash
    ```

    这样会导致诸如 `su`、`sudo` 等提权命令失效；同时 seccomp 过滤会在权限放弃后再生效，
    从而可采用更严格的过滤策略。详情见[内核文档](https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt)。

    在 Windows 上，可以用 `--security-opt` 指定 `credentialspec` 选项，
    其格式为 `file://spec.txt` 或 `registry://keyname`。

    ### 停止容器的超时设置 (--stop-timeout) {#stop-timeout}

    `--stop-timeout` 设置在发送预定义信号（见 `--stop-signal`）后等待容器退出的秒数。
    若超时时间到达仍未退出，容器会被 `SIGKILL` 强制终止。

    若将 `--stop-timeout` 设为 `-1`，则不设置超时，守护进程会无限期等待容器退出。

    默认值由守护进程决定：Linux 容器为 10 秒，Windows 容器为 30 秒。

    ### 指定容器隔离技术 (--isolation) {#isolation}

    当在 Windows 上运行容器时该选项很有用。`--isolation=<value>` 用于设置容器的隔离技术。
    在 Linux 上仅支持 `default`（使用 Linux 命名空间）。以下两条命令在 Linux 上等价：

    ```console
    $ docker run -d busybox top
    $ docker run -d --isolation default busybox top
    ```

    在 Windows 上，`--isolation` 可取以下值：

    | 取值      | 说明                                                                                       |
    |:----------|:-------------------------------------------------------------------------------------------|
    | `default` | Use the value specified by the Docker daemon's `--exec-opt` or system default (see below). |
    | `process` | Shared-kernel namespace isolation.                                                         |
    | `hyperv`  | Hyper-V hypervisor partition-based isolation.                                              |

    Windows Server 上的默认隔离为 `process`；Windows 客户端（如 Windows 10）默认为 `hyperv`。
    `process` 性能更好，但要求镜像与宿主机使用相同内核版本。

    在 Windows Server 上，默认配置下以下命令等价，均为 `process` 隔离：

    ```powershell
    PS C:\> docker run -d microsoft/nanoserver powershell echo process
    PS C:\> docker run -d --isolation default microsoft/nanoserver powershell echo process
    PS C:\> docker run -d --isolation process microsoft/nanoserver powershell echo process
    ```

    如果在守护进程上设置了 `--exec-opt isolation=hyperv`，或连接到 Windows 客户端的守护进程，
    则以下命令等价，结果为 `hyperv` 隔离：

    ```powershell
    PS C:\> docker run -d microsoft/nanoserver powershell echo hyperv
    PS C:\> docker run -d --isolation default microsoft/nanoserver powershell echo hyperv
    PS C:\> docker run -d --isolation hyperv microsoft/nanoserver powershell echo hyperv
    ```

    ### 指定容器可用内存上限 (-m, --memory) {#memory}

    该参数始终设置容器可用内存的“上限”。在 Linux 上通过 cgroup 实现，容器内应用可在
    `/sys/fs/cgroup/memory/memory.limit_in_bytes` 查询到该限制。

    在 Windows 上，行为因隔离方式不同而异：

    - `process` 隔离下，Windows 向容器内应用报告的是宿主机总内存，而非你设置的内存上限

        ```powershell
        PS C:\> docker run -it -m 2GB --isolation=process microsoft/nanoserver powershell Get-ComputerInfo *memory*

        CsTotalPhysicalMemory      : 17064509440
        CsPhyicallyInstalledMemory : 16777216
        OsTotalVisibleMemorySize   : 16664560
        OsFreePhysicalMemory       : 14646720
        OsTotalVirtualMemorySize   : 19154928
        OsFreeVirtualMemory        : 17197440
        OsInUseVirtualMemory       : 1957488
        OsMaxProcessMemorySize     : 137438953344
        ```

    - `hyperv` 隔离下，Windows 会创建一个足以容纳该上限的 utility VM（加上承载容器所需的最小 OS），并将其大小报告为 “Total Physical Memory”

        ```powershell
        PS C:\> docker run -it -m 2GB --isolation=hyperv microsoft/nanoserver powershell Get-ComputerInfo *memory*

        CsTotalPhysicalMemory      : 2683355136
        CsPhyicallyInstalledMemory :
        OsTotalVisibleMemorySize   : 2620464
        OsFreePhysicalMemory       : 2306552
        OsTotalVirtualMemorySize   : 2620464
        OsFreeVirtualMemory        : 2356692
        OsInUseVirtualMemory       : 263772
        OsMaxProcessMemorySize     : 137438953344
        ```

    ### 运行时配置命名空间内核参数（sysctl）(--sysctl) {#sysctl}

    `--sysctl` 用于在容器内设置“命名空间范围”的内核参数。
    例如，在容器的网络命名空间中开启 IP 转发：

    ```console
    $ docker run --sysctl net.ipv4.ip_forward=1 someimage
    ```

    > [!NOTE]
    > 并非所有 sysctl 都具备命名空间隔离。
    > Docker 不支持在容器内修改会影响宿主机的 sysctl。
    > 随着内核演进，预计会有更多 sysctl 支持命名空间。


    #### 当前支持的 sysctl

    IPC 命名空间：

    - `kernel.msgmax`, `kernel.msgmnb`, `kernel.msgmni`, `kernel.sem`,
      `kernel.shmall`, `kernel.shmmax`, `kernel.shmmni`, `kernel.shm_rmid_forced`.
    - 以 `fs.mqueue.*` 开头的 sysctl
    - 若使用 `--ipc=host`，上述 sysctl 不允许设置

    网络命名空间：

    - 以 `net.*` 开头的 sysctl
    - 若使用 `--network=host`，上述 sysctl 不允许设置
deprecated: false
hidden: false
experimental: false
experimentalcli: false
kubernetes: false
swarm: false

